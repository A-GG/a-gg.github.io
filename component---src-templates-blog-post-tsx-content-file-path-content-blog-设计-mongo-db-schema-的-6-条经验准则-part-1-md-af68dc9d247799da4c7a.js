"use strict";(self.webpackChunkw1zd_lair=self.webpackChunkw1zd_lair||[]).push([[4429],{4150:function(n,a,e){e.r(a),e.d(a,{default:function(){return d}});var s=e(8453),t=e(6540);function l(n){const a=Object.assign({p:"p",img:"img",h2:"h2",a:"a",span:"span",ul:"ul",li:"li",hr:"hr"},(0,s.RP)(),n.components);return t.createElement(t.Fragment,null,t.createElement(a.p,null,t.createElement(a.img,{src:"https://raw.githubusercontent.com/w1zd/image-hosting/main/img/2022/05/10/11-41-46-d2582e9ef5586bc819fec7cc1df972bf-mongodb-91c09c.jpeg",alt:""}),"\n作者：MongoDB 首席技术支持工程师 William Zola"),"\n",t.createElement(a.p,null,"“我用SQL很长时间了, 但是 MongoDB 对我而言算是一个新东西。在 MongoDB 里面我该怎么处理___一对多___的关系呢？”这是我在 MongoDB 工作期间，用户问的最多的一个问题。"),"\n",t.createElement(a.p,null,"这个问题我没办法用简单的一两句话就给说明白，因为不止一种方式可以做到这件事情。对于 SQL 中经常谈及的比较扁平化的___一对多___这个数据表之间的关系，MongoDB 有非常丰富而且细腻的词汇来表达它。接下来我们就一起看一下，在 MongoDB 中处理___一对多___这种关系的时候，你都有哪些选择。"),"\n",t.createElement(a.p,null,"由于要讲的东西太多，我会把内容分为 3 部分来向说。在第一部分中，我会给大家讲解在MongoDB中实现___一对多___关系的 3 种基本方式；在第二部分中，我会介绍更加复杂的 Schema 设计方式，包括非规范化和双向引用；在最有一部分中，我会带大家回顾所有内容，并针对在 MongoDB 中设计___一对多___关系时，你会考虑的上千种选择（真的是上千种哦），给你一些建议。"),"\n",t.createElement(a.p,null,"在大多数新手看来，MongoDB 中设计这种___一对多___的关系只有一种方案，那就是在父文档（parent document)中嵌入一个包含子文档（sub-document)的数组，但事实并非如此。但这只是因为你可以使用嵌入方式（embedding），并不意味着你应该使用嵌入方式（embedding）。"),"\n",t.createElement(a.p,null,"在设计一个 MongoDB Schema 的时候，你应该从一个你在使用 SQL 的时候从来都不会考虑的问题开始：关系（Relationship）的基数（cardinality",t.createElement("sup",null,"注[1]"),"）是什么？换句更通俗易懂的话来讲：你需要用更准确的方式来描述你的___一对多___关系，是”一对几个”，还是“一对很多个”，还是___一对超级多___，这对你讲采用哪种方式来建立你的关系模型，有着至关重要的影响。"),"\n",t.createElement(a.h2,{id:"基础一对几",style:{position:"relative"}},t.createElement(a.a,{href:"#%E5%9F%BA%E7%A1%80%E4%B8%80%E5%AF%B9%E5%87%A0","aria-label":"基础一对几 permalink",className:"anchor before"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"基础：一对几"),"\n",t.createElement(a.p,null,"举个___一对几个___这种关系的简单例子，一个人和他的地址。这是进行嵌入方式（embedding）很好的一个例子——你可以把 addresses 作为一个数组，嵌套到你的 Person 对象中:"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token operator">></span> db.person.<span class="token function-name function">findOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\tname: <span class="token string">"岳云鹏"</span>,\n\tssn: <span class="token string">"123-456-7890"</span>,\n\taddresses <span class="token builtin class-name">:</span> <span class="token punctuation">[</span>\n     <span class="token punctuation">{</span> street: <span class="token string">\'史各庄东路108号\'</span>, city: <span class="token string">\'北京\'</span>, cc: <span class="token string">\'China\'</span> <span class="token punctuation">}</span>,\n     <span class="token punctuation">{</span> street: <span class="token string">\'王府井大街250号\'</span>, city: <span class="token string">\'北京\'</span>, cc: <span class="token string">\'China\'</span> <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"这种设计体现了嵌入方式（embedding）的所有优点和缺点。最大的好处在于，你不需要在做一个额外的查询来获取嵌入内容的详细信息；而最大的坏处在于，你没办法以独立的实体方式来访问嵌入到Document中的内容。"),"\n",t.createElement(a.p,null,"举个例子：假设您正在设计一个任务跟踪系统，那么每个人都会被分配许多任务。将任务嵌入到 Person 文档中，会使诸如“显示明天到期的所有任务”这样的查询变的非常困难，在下一篇文章中，我会介绍更适合这个用例的设计。"),"\n",t.createElement(a.h2,{id:"基础一对多",style:{position:"relative"}},t.createElement(a.a,{href:"#%E5%9F%BA%E7%A1%80%E4%B8%80%E5%AF%B9%E5%A4%9A","aria-label":"基础一对多 permalink",className:"anchor before"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"基础：一对多"),"\n",t.createElement(a.p,null,"举一个___一对很多个___这种关系的例子，产品的可替换部分的订单系统。每种产品可能有几百个可替换的部件，但一般不会超过几千个。这个是一个很好的引用方式用例——你可以把可替换部件的 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ObjectIDs</code>'}})," 作为一个数组，放到 product 文档中去。（在这个例子中为了便于阅读，我用了两个字节的 ObjectID，但是实际开发当中 ObjectID 应该是 12 个字节的）"),"\n",t.createElement(a.p,null,"每个可替换部件都有自己的文档。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token operator">></span> db.parts.<span class="token function-name function">findOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    _id <span class="token builtin class-name">:</span> ObjectID<span class="token punctuation">(</span><span class="token string">\'AAAA\'</span><span class="token punctuation">)</span>,\n    partno <span class="token builtin class-name">:</span> <span class="token string">\'123-aff-456\'</span>,\n    name <span class="token builtin class-name">:</span> <span class="token string">\'#4 grommet\'</span>,\n    qty: <span class="token number">94</span>,\n    cost: <span class="token number">0.94</span>,\n    price: <span class="token number">3.99</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"同样，每个产品都有自己的文档，其中包含对组成该产品的可替换部件的 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ObjectID</code>'}})," 引用数组"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token operator">></span> db.products.<span class="token function-name function">findOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    name <span class="token builtin class-name">:</span> <span class="token string">\'left-handed smoke shifter\'</span>,\n    manufacturer <span class="token builtin class-name">:</span> <span class="token string">\'Acme Corp\'</span>,\n    catalog_number: <span class="token number">1234</span>,\n    parts <span class="token builtin class-name">:</span> <span class="token punctuation">[</span>     // 可替换部件的数组引用\n        ObjectID<span class="token punctuation">(</span><span class="token string">\'AAAA\'</span><span class="token punctuation">)</span>,    // reference to the <span class="token comment">#4 grommet above</span>\n        ObjectID<span class="token punctuation">(</span><span class="token string">\'F17C\'</span><span class="token punctuation">)</span>,    // reference to a different Part\n        ObjectID<span class="token punctuation">(</span><span class="token string">\'D2AA\'</span><span class="token punctuation">)</span>,\n        // etc\n    <span class="token punctuation">]</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"然后，你需要使用应用程序级别的联接查询来检索特定产品的可替换零件："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">// 获取指定catalog number对应的产品文档\n<span class="token operator">></span> product <span class="token operator">=</span> db.products.findOne<span class="token punctuation">(</span><span class="token punctuation">{</span>catalog_number: <span class="token number">1234</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n// 获取当前这个产品所有的可替换部件\n<span class="token operator">></span> product_parts <span class="token operator">=</span> db.parts.find<span class="token punctuation">(</span><span class="token punctuation">{</span>_id: <span class="token punctuation">{</span> <span class="token variable">$in</span> <span class="token builtin class-name">:</span> product.parts <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span>.toArray<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"为了使操作效率更高，你需要在 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">product.catlog_number</code>'}})," 上创建索引。要注意，  ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">parts._id</code>'}})," 上始终会有索引，所以这个查询总是高效的。"),"\n",t.createElement(a.p,null,"这种引用的风格和嵌入方式有互补的优缺点。每个 Part (可替换部件)都是一个独立的 Document，因此独立的搜索和更新 Part 会变得特别容易。使用这中模式的代价在于，如果你想要获取一个商品的某个部件的详情，你需要进行二次查询。(在阅读本文 Part2 之前，可以先这么理解）"),"\n",t.createElement(a.p,null,"还有一个额外的好处就是，这种 Schema 设计方案下，你可以让一个 Part (可替换部件) 被多个 Product (商品) 使用。这样不需要任何额外操作的情况下，你的”一对多”的关系，就变成了“多对多”关系。"),"\n",t.createElement(a.h2,{id:"基础一对超级多",style:{position:"relative"}},t.createElement(a.a,{href:"#%E5%9F%BA%E7%A1%80%E4%B8%80%E5%AF%B9%E8%B6%85%E7%BA%A7%E5%A4%9A","aria-label":"基础一对超级多 permalink",className:"anchor before"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"基础：一对超级多"),"\n",t.createElement(a.p,null,"一个用于收集不同机器日志消息的日志系统，应该算是一个___一对超级多___这种关系的例子。任何一个主机所产生的日志信息都足以让文档大小超过 MongoDB 限制的 16MB ，哪怕你只是把 ObjectID 存放在数组中。这是一个“父级引用”的经典用例——你有个针对主机的 Document，然后将主机的 ObjectID 存储在记录日志消息的 Document 中。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token operator">></span> db.hosts.<span class="token function-name function">findOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    _id <span class="token builtin class-name">:</span> ObjectID<span class="token punctuation">(</span><span class="token string">\'AAAB\'</span><span class="token punctuation">)</span>,\n    name <span class="token builtin class-name">:</span> <span class="token string">\'goofy.example.com\'</span>,\n    ipaddr <span class="token builtin class-name">:</span> <span class="token string">\'127.66.66.66\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token operator">></span>db.logmsg.<span class="token function-name function">findOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token function">time</span> <span class="token builtin class-name">:</span> ISODate<span class="token punctuation">(</span><span class="token string">""</span><span class="token number">2014</span>-03-28T09:42:41.284Z<span class="token string">".382Z"</span><span class="token punctuation">)</span>,\n    message <span class="token builtin class-name">:</span> <span class="token string">\'cpu is on fire!\'</span>,\n    host: ObjectID<span class="token punctuation">(</span><span class="token string">\'AAAB\'</span><span class="token punctuation">)</span>       // 引用主机 Document\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"你可以使用一个应用程序级别的关联查询来查找最近的5,000条日志记录。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">// 先找到指定的主机\n<span class="token operator">></span> <span class="token function">host</span> <span class="token operator">=</span> db.hosts.findOne<span class="token punctuation">(</span><span class="token punctuation">{</span>ipaddr <span class="token builtin class-name">:</span> <span class="token string">\'127.66.66.66\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // 这里假设 ipaddr： <span class="token number">127.66</span>.66.66 是唯一的\n// 在找到主机对应的最近的5000条日志信息\n<span class="token operator">></span> last_5k_msg <span class="token operator">=</span> db.logmsg.find<span class="token punctuation">(</span><span class="token punctuation">{</span>host: host._id<span class="token punctuation">}</span><span class="token punctuation">)</span>.sort<span class="token punctuation">(</span><span class="token punctuation">{</span>time <span class="token builtin class-name">:</span> -1<span class="token punctuation">}</span><span class="token punctuation">)</span>.limit<span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span>.toArray<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>'}}),"\n",t.createElement(a.h2,{id:"总结",style:{position:"relative"}},t.createElement(a.a,{href:"#%E6%80%BB%E7%BB%93","aria-label":"总结 permalink",className:"anchor before"},t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"总结"),"\n",t.createElement(a.p,null,"因此，尽管上面讲的东西都很基础，但是我们会发现，在设计 MonogDB Schema 的时候明显要比设计关系型的 Schema 想的更多。你需要思考的有两个因素："),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"在你的___一对多___关系中，”多“的这一方，需要被设计成单独的实体吗？"),"\n",t.createElement(a.li,null,"你设计的关系的基数（cardinality）是什么？ 一对多？一对很多？还是一对超级多？"),"\n"),"\n",t.createElement(a.p,null,"基于这两个因素，您可以选择三种基本的___一对多___模式设计之一："),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"如果你的基数是一对几的，并且无需在父对象的上下文之外访问嵌入的对象，则将”多“的那一边嵌入到父对象中"),"\n",t.createElement(a.li,null,"如果你的基数是一对多的，或者由于其他任何原因，”多“这一边对象应该独立存在，则使用对”多“这一边的对象的引用数组"),"\n",t.createElement(a.li,null,"如果你的基数是一对超级多，请在”多“那边的对象中使用对”一“那边的引用"),"\n"),"\n",t.createElement(a.p,null,"下篇文章中，我们将看到如何使用双向关系和非规范化来增强这些基本 Schema 的性能。"),"\n",t.createElement(a.hr),"\n",t.createElement(a.p,null,"[1] ",t.createElement(a.a,{href:"https://www.techopedia.com/definition/18/cardinality-databases"},"techopedia 中对 Cardinality 的解释")))}var c=function(n){void 0===n&&(n={});const{wrapper:a}=Object.assign({},(0,s.RP)(),n.components);return a?t.createElement(a,n,t.createElement(l,n)):l(n)},p=e(1468),o=e(7947),r=e(1327),i=e(2171),u=e(9739);const m=n=>{let{data:a,pageContext:e,children:l}=n;const c=a.mdx,{title:m,postCopyright:d,author:g,siteUrl:h}=a.site.siteMetadata,{previous:k,next:E}=e,_=(0,p.d4)((n=>n.isDarkMode));return(0,t.useEffect)((()=>{(0,u.A)(".post-content img",{background:"#292a2d"})}),[]),t.createElement(o.A,{isFocus:!1,title:c.frontmatter.title,description:c.frontmatter.description},t.createElement("div",{className:"container"},t.createElement("article",{className:"post-wrap"},t.createElement("header",{className:"post-header"},t.createElement("h1",{className:"post-title"},c.frontmatter.title),t.createElement("div",{className:"post-meta"},a.site.siteMetadata.author.name,"  /  ",t.createElement("span",{className:"post-time"},c.frontmatter.date)," ")),t.createElement("div",{className:"post-content"},t.createElement(s.xA,null,l)),d&&t.createElement("section",{className:"post-copyright"},t.createElement("p",{className:"copyright-item"},t.createElement("span",null,"Author: "),t.createElement("span",null,g.name)),t.createElement("p",{className:"copyright-item"},t.createElement("span",null,"Permalink:"),t.createElement("span",null,t.createElement("a",{href:h+c.fields.slug}," ",h+c.fields.slug," "))),t.createElement("p",{className:"copyright-item"},t.createElement("span",null,"License: "),t.createElement("span",null,t.createElement("a",{href:"http://creativecommons.org/licenses/by-nc/4.0/"},"CC-BY-NC-4.0")))),t.createElement("section",{className:"post-tags"},t.createElement("div",null,t.createElement("span",null,"Tag(s):"),t.createElement("span",{className:"tag"},0!==c.frontmatter.tags.length&&c.frontmatter.tags.map((n=>t.createElement("a",{key:n,href:`/tag/${n}`},"#",n))))),t.createElement("div",null,t.createElement("a",{href:"#/",onClick:()=>{window.history.back()}},"back"),t.createElement("span",null," · "),t.createElement("a",{href:a.site.siteMetadata.siteUrl},"home"))),t.createElement("section",{className:"post-nav"},k?t.createElement("a",{className:"prev",rel:"prev",href:k.fields.slug},k.frontmatter.title):t.createElement("span",{className:"prev"},"No More"),E?t.createElement("a",{className:"next",rel:"next",href:E.fields.slug},E.frontmatter.title):t.createElement("span",{className:"next"},"No More")),t.createElement(i.A,{id:"comment",repo:"w1zd/w1zd.github.io",repoId:"MDEwOlJlcG9zaXRvcnkyODg3MTA5NjA=",category:"Announcements",categoryId:"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE1OTcy",mapping:"og:title",theme:`https://wizd.dev/giscus-themes/${_?"dark":"light"}.css`,reactionsEnabled:"1",loading:"lazy"}),c.frontmatter.toc&&t.createElement(r.A,null))))};function d(n){return t.createElement(m,n,t.createElement(c,n))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-tsx-content-file-path-content-blog-设计-mongo-db-schema-的-6-条经验准则-part-1-md-af68dc9d247799da4c7a.js.map