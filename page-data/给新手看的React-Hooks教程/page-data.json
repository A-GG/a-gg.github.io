{"componentChunkName":"component---src-templates-blog-post-tsx-content-file-path-content-blog-给新手看的-react-hooks教程-md","path":"/给新手看的React-Hooks教程/","result":{"data":{"site":{"siteMetadata":{"title":"Wizard's Lair","postCopyright":true,"siteUrl":"https://wizd.dev","author":{"name":"w1zd"}}},"mdx":{"id":"7d8c206c-6bfb-5e6f-89ec-2d93dc1d5c80","excerpt":"\"Hooks 到底是个啥玩意儿？？？\" 你是不是有这样的疑惑？在你自认为已经了解了差不多 React 所有的内容的时候，Hooks 就这么出现了。\n\n这就是前端开发人员的日常，技术从未停止更新。\n\n学习新东西是一件很棒的事情吗？当然是！但有的时候我们又不得不思考：”为什么要学它？这个新东西有啥意义？我是必须得学他吗？“。…","body":"![](https://raw.githubusercontent.com/w1zd/image-hosting/main/img/2022/05/10/11-42-11-0f76f4f01901829907f9af90ae1aa770-reacthooks-586d4b.png)\n\"Hooks 到底是个啥玩意儿？？？\"\n\n你是不是有这样的疑惑？在你自认为已经了解了差不多 React 所有的内容的时候，Hooks 就这么出现了。\n\n这就是前端开发人员的日常，技术从未停止更新。\n\n学习新东西是一件很棒的事情吗？当然是！但有的时候我们又不得不思考：”为什么要学它？这个新东西有啥意义？我是必须得学他吗？“。\n\n针对 Hooks 而言，上面的这个问题答案是否定的，你不需要立马就学它。如果您一直在使用 React，并且迄今为止一直在使用基于类的组件，那么就不必急于转向 Hooks。Hooks 是可选的，可以与现有组件配合使用。我相信当你因为要使用新东西而不得不重写整个代码库，你整个人都是崩溃的。\n\n## 在函数组件中使用状态\n\n在使用 Hooks 之前，我们不能在函数组件中使用状态。这就意味着，如果您有一个经过精心设计和测试的函数组件，突然需要存储状态，那么你就不得不把他重构为一个类组件。\n\n牛逼的来了，Hooks 让函数组件也能使用状态，就意味着我们不需要重构之前自己的写的代码，[可以点击这篇文章查看更多](https://scotch.io/courses/5-essential-react-concepts-to-know-before-learning-redux/presentational-and-container-component-pattern-in-react)。\n\n## 类组件很笨重\n\n我们不的不承认的是，类组件附带了太多的东西。constructor，binding，“this”无处不在。使用函数组件可以消除许多这种情况，能让我们的代码更容易维护。\n\n可以在[React文档中了解更多相关内容](https://reactjs.org/docs/hooks-intro.html#classes-confuse-both-people-and-machines)\n\n## 更高的可读性\n\n由于 Hooks 允许我们在函数组件中使用状态，因此和类组件相比，这意味同样的功能，我们写出来的代码会更好。 这也会让我们的代码更具可读性。 我们再也不用担心方法是不是绑定了 `this`，也不必记住 `this` 之间的关系等等。 我们可以专心写代码了。\n\n## React State Hook\n\n状态，是React生态系统的基础。接下来我将通过介绍最常见的 Hook —— `useState()` 来让大家初步了解 Hooks。\n\n我们先来看一下具有状态的类组件。\n\n```jsx\nimport React, { Component } from 'react';\nimport './styles.css';\n\nclass Counter extends Component {\n\tstate = {\n\t\tcount: this.props.initialValue,\n\t};\n\n\tsetCount = () => {\n\t\tthis.setState({ count: this.state.count + 1 });\n\t};\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<h2>This is a counter using a class</h2>\n\t\t\t\t<h1>{this.state.count}</h1>\n\n\t\t\t\t<button onClick={this.setCount}>Click to Increment</button>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default Counter;\n```\n\n有了React Hooks 之后，我们可以重写这个类组件并删除很多内容，使其更易理解\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction CounterWithHooks(props) {\n\tconst [count, setCount] = useState(props.initialValue);\n\n\treturn (\n\t\t<div>\n\t\t\t<h2>This is a counter using hooks</h2>\n\t\t\t<h1>{count}</h1>\n\t\t\t<button onClick={() => setCount(count + 1)}>Click to Increment</button>\n\t\t</div>\n\t);\n}\n\nexport default CounterWithHooks;\n```\n\n代码变少了，但这到底是啥情况呢？\n\n## React State Syntax\n\n在上面的代码里，我们已经用到了人生中第一个 React Hook\n\n```jsx\nconst [count, setCount] = useState();\n```\n\n简单来讲，这里使用了数组的结构赋值。\n\n`useState()` 函数为我们提供了两个东西:\n\n\t* 一个保存状态值的变量，在本例中称为count;\n\t* 一个更改值的函数，在本例中称为setCount。\n\n当然，你可以为这两个东西起任何你想要的名字。\n\n```jsx\nconst [myCount, setCount] = useState(0);\n```\n\n而且，你也可以在你的代码中像使用正常变量/函数一样去用他们。\n\n```jsx\nfunction CounterWithHooks() {\n\tconst [count, setCount] = useState();\n\n\treturn (\n\t\t<div>\n\t\t\t<h2>This is a counter using hooks</h2>\n\t\t\t<h1>{count}</h1>\n\t\t\t<button onClick={() => setCount(count + 1)}>Click to Increment</button>\n\t\t</div>\n\t);\n}\n```\n\n注意最上面的的`useState` Hook。 我们声明、结构了2个东西：\n\n* counter：是用来保存状态的\n* setCounter：是用来更改计数器变量的函数\n\n往下看代码，您会看到这一行：\n\n```jsx\n<h1>{count}</h1>\n```\n\n这是一个使用 Hooks 变量的例子。在JSX中，我们将 `count` 变量放在 `{}` 中，然后作为JavaScript执行它，最后将 `count` 的值将展示在页面上。\n\n我们来对照一下我们之前在类组件中使用状态的方式：\n\n```jsx\n<h1>{this.state.count}</h1>\n```\n\n你会发现，我么再也不需要关注 `this` 的使用了，这使我们的编码工作变得更加轻松了。\n\n比如，当你没定义 `{count}` 的时候，VS Code编辑器直接就给你报警告了，你就更早的发现错误。 但是在运行代码之前，VS Code 可不会知道 `{this.state.count}` 是不是定义了。\n\n我们继续往下看\n\n```jsx\n<button onClick={() => setCount(count + 1)}>Click to Increment</button>\n```\n\n在这行代码中，我们使用 `setCount` 函数来更改 `count` 变量。\n\n单击按钮的时侯，我们把 `count` 变量更新为1。由于状态变化，因此会触发视图重新渲染，React 会用新的 `count `值为我们更新视图。 真香！\n\n## 那我怎么给数据一个初始值呢？\n\n您可以通过给`useState()`传递参数来设置初始状态。 可以是一个硬编码的值：\n\n```jsx\n const [count, setCount] = useState(0);\n```\n\n或者你也可以用 `props` 传进来的值作为初始值：\n\n```jsx\n const [count, setCount] = useState(props.initialValue);\n```\n\n不论你的`props.initialValue`是啥，都会赋值给 `count` 作为初始值。\n\n总结一下：`useState` 最爽的地方在于，你可以像使用正常变量、函数一样处理你的状态。\n\n## 那如果我有多个状态数据咋办?\n\n这是就是Hooks另外一个牛逼的地方了，在组件里，`useState`你想用多少次，就用多少次：\n\n```jsx\n const [count, setCount] = useState(props.initialValue);\n const [title, setTitle] = useState(\"This is my title\");\n const [age, setAge] = useState(25);\n```\n\n如你所见，我们现在有3个独立的状态对象。例如，如果我们想更新年龄，只需调用`setAge()`函数。`count`和`title`也是一样。我们不再受制于旧的笨重的类组件方式——用`setState()`来管理一个超大的状态对象.\n\n```jsx\nthis.setState({ count: props.initialValue, title: \"This is my title\", age: 25 })\n```\n\n## 那数据更新的时候，我要做一些事情怎么做？\n\n在使用函数组件 + React Hooks 这种模式下，我们再也不用去管什么生命周期了，什么 `componentDidMount`、`componentDidUpdate`都可以统统见鬼去了。\n\n你可能会问，那我用啥？？？别慌，兄弟！ React 给我们提供了另外一个钩子来干这事儿。\n\n## useEffect\n\n效果钩子 `useEffect` 是我们处理“副作用”的地方。\n\n呃,副作用？那是啥? \n\n### 副作用\n\n那我们就先偏离一下正题，讨论一下副作用到底是什么。这有助于我们理解 `useEffect()` 的作用以及为什么他很有用。\n\n一个你看不懂的无聊的正规解释应该是：\n\n> ​\t“在编程中，副作用是指在程序处理过程改变了程序范围之外的变量”\n\n用 React 术语来说，副作用其实意味着“当组件的变量或状态因某些外部事物而改变”。 例如：\n\n* 组件接受了一个改变组件本身状态的props\n\n* 当组件进行接口调用并在接口返回结果是执行了某些操作（例如，更改了组件的状态）\n\n那么为什么称之为副作用呢？ \n\n***我们不能确定这些代码的执行结果是什么***。 我们永远无法百分百确定我们的组件会接收到什么样的 `props `，也无法确定接口调用返回的结果数据是什么。 而且，我们无法确定这将如何影响我们的组件。\n\n当然，我们也可以编写代码校验、处理错误等，但是我们最终还是不能确定这样的事情带来的副作用是什么。\n\n所以可以这么说，当组件的状态因为一些外界因素改变的时候，这就可以称作副作用。\n\n\n\n好了，我们可以回正题了。继续来看`useEffect`这个Hook。\n\n在使用函数组件时，我们不再使用生命周期钩子函数，例如 `componentDidMount`，`componentDidUpdate`等。因此，可以这么说，`useEffect` Hook 代替了之前我们用到的React钩子函数。\n\n让我们比较一下基于类的组件和`useEffect` Hooks的使用方式\n\n```jsx\nimport React, { Component } from 'react';\n\nclass App extends Component {\n\tcomponentDidMount() {\n\t\tconsole.log('I have just mounted!');\n\t}\n\n\trender() {\n\t\treturn <div>Insert JSX here</div>;\n\t}\n}\n```\n\n\n\n用了`useEffect`之后\n\n```jsx\nfunction App() {\n\tuseEffect(() => {\n\t\tconsole.log('I have just mounted!');\n\t});\n\n\treturn <div>Insert JSX here</div>;\n}\n```\n\n在继续往下之前，我们必须要知道一件事儿，在默认情况下，`useEffect` Hook 在每次渲染和重新渲染时都会执行。 \n\n因此，只要组件中的状态发生变化或组件收到新的`props`时，组件都会重新渲染并导致`useEffect Hook 再次运行。\n\n## 能不能只执行一次useEffect  (就像 componentDidMount 一样)\n\n如果 `useEffect` Hook 在组件每次渲染时都运行，那么我们怎么才能做到 Hook 在挂载组件时仅运行一次？ \n\n例如，如果组件从接口获取数据，我们肯定不希望每次重新渲染组件时都去重新请求下数据吧？\n\n`useEffect()` 钩子接受第二个参数，是一个数组，其中包含导致 `useEffect` 钩子运行的依赖项的列表。当这些依赖项更改时，它将触发 Effect Hook。如果想要只运行一次 Effect Hook，那直接给他传递一个空数组，就OK啦！！\n\n```jsx\nuseEffect(() => {\n\tconsole.log('This only runs once');\n}, []);\n```\n\n这就意味着 useEffect Hook 将在第一次渲染时正常运行。然而，当你的组件重新渲染时，useEffect 会想 “好吧，我已经运行了，数组中啥也没有，我没啥依赖项，谁变都跟我没关系了，所以我不必再运行了。” 然后就什么也不做了。\n\n> 总结： 空数组就意味着useEffect Hook只在挂载时运行一次\n\n\n\n## 当有内容更新时使用effect (就像componentDidUpdate一样)\n\n我们已经介绍了如何确保 useEffect Hook仅运行一次，但是当我们的组件收到新的 `props` 时该怎么办？ 或者我们要在状态更改时运行一些代码？ 其实Hooks 也能处理！\n\n```jsx\n useEffect(() => {\n\tconsole.log(\"The name props has changed!\")\n }, [props.name]);\n```\n\n请注意，这次我们如何将东西传递给useEffect数组的，`props.name`。\n\n在这种情况下，useEffect Hook 将像往常一样在首次加载时运行。 每当您的组件从其父组件收到新的`props.name`时，都会触发useEffect Hook，并且运行其中的代码。\n\n\n\n我们也可以使用状态变量来做同样的事情：\n\n```jsx\nconst [name, setName] = useState(\"Chris\");\n\n useEffect(() => {\n    console.log(\"The name state variable has changed!\");\n }, [name]);\n```\n\n每当`name`发生变化时，组件就会重新渲染 ，useEffect Hook 就会运行并输出消息。而且因为这是一个数组，我们其实可以向它添加多个东西：\n\n```jsx\nconst [name, setName] = useState(\"Chris\");\n\n useEffect(() => {\n    console.log(\"Something has changed!\");\n }, [name, props.name]);\n```\n\n这样，当 `name` 状态变量更改或 `props.name` 更改时，useEffect Hook 都将运行并显示控制台消息。\n\n## 那我们能用componentWillUnmount吗？\n\n想要在组件即将卸载时运行一个Hook，我们只需从`useEffect` Hook 返回一个函数\n\n```jsx\nuseEffect(() => {\n\tconsole.log('running effect');\n\n\treturn () => {\n\t\tconsole.log('unmounting');\n\t};\n});\n```\n\n## 那我们可以多个不同的 Hooks 一起使用吗？\n\n当然! 你可以在组件中使用任意数量的Hooks，并根据需要混合使用\n\n```jsx\nfunction App = () => {\n\tconst [name, setName] = useState();\n\tconst [age, setAge] = useState();\n\n\tuseEffect(()=>{\n\t\tconsole.log(\"component has changed\");\n\t}, [name, age])\n\n\treturn(\n\t\t<div>Some jsx here...<div>\n\t)\n}\n```\n\n## 小结- 接下来干啥呢？\n\n你这不已经学会React Hooks了么，Hooks允许我们使用老式的JavaScript函数来创建更简单的React组件，并减少大量代码。\n\n\n\n接下来，手不痒痒么？当然是自己赶紧动手那Hooks做项目体验去啊！","fields":{"slug":"/给新手看的React-Hooks教程/"},"frontmatter":{"title":"给新手看的 React Hooks 教程","date":"November 27, 2019","description":"Hooks 到底是个啥玩意儿？？？","categories":["技术文章"],"tags":["React Hooks"],"toc":null}}},"pageContext":{"slug":"/给新手看的React-Hooks教程/","previous":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/深入了解Vue-js源码-2-initMixin.md"},"fields":{"slug":"/深入了解Vue-js源码-2-initMixin/"},"frontmatter":{"title":"深入了解Vue.js源码(#2-initMixin-part1)"}},"next":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/如何在-React-中使用节流和防抖并将他们抽象成-Hooks.md"},"fields":{"slug":"/如何在-React-中使用节流和防抖并将他们抽象成-Hooks/"},"frontmatter":{"title":"如何在 React 中使用节流和防抖并将他们抽象成 Hooks"}},"frontmatter":{"title":"给新手看的 React Hooks 教程","date":"2019-11-27T15:24:47.284Z","tags":["React Hooks"],"categories":["技术文章"],"description":"Hooks 到底是个啥玩意儿？？？"}}},"staticQueryHashes":["2786614800","3000541721","3828236571"],"slicesMap":{}}