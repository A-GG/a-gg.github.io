{"componentChunkName":"component---src-templates-blog-post-tsx-content-file-path-content-blog-es-6-常用内容介绍-md","path":"/ES6常用内容介绍/","result":{"data":{"site":{"siteMetadata":{"title":"Wizard's Lair","postCopyright":true,"siteUrl":"https://wizd.dev","author":{"name":"w1zd"}}},"mdx":{"id":"831e211f-56bb-5caa-b3cb-594af81e491f","excerpt":"变量声明- let、const let\n\nES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。\n\n特点：\n\n1 块级作用域（ES6） 2 先声明再使用 3 不允许重复声明\nconst\nconst声明一个只读的常量。一旦声明，常量的值就不能改变。…","body":"\n\n## 变量声明- let、const\n\n### let\n\n- ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。\n\n- `let`特点：\n  - 1 块级作用域（ES6）\n  - 2 先声明再使用\n  - 3 不允许重复声明\n\n```javascript\n/* 基本使用 */\nlet num = 2\n\n{\n  let num = 9\n}\nconsole.log(num)\n```\n\n### const\n\n- const声明一个**只读的常量**。一旦声明，常量的值就不能改变。\n- const的作用域与let命令相同：只在声明所在的块级作用域内有效\n\n```javascript\nconst PI = 3.1415\nconsole.log(PI) // 3.1415\n\n// 修改 常量的值 会报错\nPI = 3 // TypeError: Assignment to constant variable.\n\n// 可以修改对象中属性的值\nconst user = { name: 'rose' }\nuser.name = 'jack'\n```\n\n## 字符串模板\n\n- 说明：代替原始的字符串拼接\n\n```javascript\nconst num = 1\n\n// ${} 中可以使用JS表达式\nlet dv = `<div>${num}</div>`\n```\n\n## 箭头函数\n\n- [ES6箭头函数](http://es6.ruanyifeng.com/#docs/function)\n- 注意 1：函数体内的this对象，就是定义时所在的对象（一般是外层函数中的this）\n- 注意 2：无法使用arguments，没有arguments对象\n- 注意 3：不能当作构造函数，不能使用new创建对象\n- 注意：**不要在Vue的选项属性或回调上使用箭头函数**\n  - 比如：`created: () => console.log(this.a)` 或 `vm.$watch('a', newValue => this.myMethod())`\n\n```javascript\n/* 语法： */\nvar fn = arg => arg\n\n// 上面的箭头函数等同于：\nvar fn = function (arg) {\n  return arg\n}\n\nvar fn = () => {\n  console.log('随机内容')\n}\n// 等同于：\nvar fn = function () {\n  console.log('随机内容')\n}\n```\n\n## rest参数\n\n- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了\n- 说明：rest 参数的类型是：数组\n- 注意：rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错\n\n```javascript\nfunction add(...values) {\n  var sum = 0\n  values.forEach(function(val) {\n    sum += val\n  })\n  return sum\n}\n\nadd(2, 5, 3) // 10\n\n\n// 报错\nfunction f(a, ...b, c) {\n  // ...\n}\n```\n\n## 解构赋值\n\n- [ES6解构](http://es6.ruanyifeng.com/#docs/destructuring)\n- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\n\n```javascript\n// 对象解构\nvar { foo, bar } = { foo: \"aaa\", bar: \"bbb\" }\nfoo // \"aaa\"\nbar // \"bbb\"\n\n// 数组解构\nvar [a, b, c] = [1, 2, 3]\n\n// 函数参数的解构赋值\nfunction foo({x, y}) {\n  console.log(x, y)\n}\n\nfoo({x: 1, y: 2}) // 1 2\n```\n\n## 对象简化语法\n\n- 对象中的属性和方法，都可以使用简化语法\n\n```javascript\n/* 属性的简化语法： */\nvar foo = 'bar'\nvar baz = {foo}\n\n// 等同于\nvar baz = {foo: foo}\n\n\n/* 方法的简化语法： */\nvar o = {\n  method() {\n    return \"Hello!\"\n  }\n}\n// 等同于\nvar o = {\n  method: function() {\n    return \"Hello!\"\n  }\n}\n```\n\n### 属性名表达式\n\n- ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。\n\n```javascript\nvar propKey = 'foo'\nvar methodKey = 'bar'\n\nvar obj = {\n  [propKey]: true,\n  ['a' + 'bc']: 123,\n  [methodKey]() {\n    return 'hi'\n  }\n}\n```\n\n## class关键字\n\n- ES6以前，JS是没有class概念的，而是通过构造函数+原型的方式来实现的\n- 注意：ES6中的class仅仅是一个语法糖，并不是真正的类，与Java等服务端语言中的类是有区别的\n- [ES6 - 文档](http://es6.ruanyifeng.com/#docs/class)\n\n```javascript\nclass Person {\n  constructor() {\n    // 实例属性\n    this.name = 'jack'\n  }\n\n  // 实例方法\n  say() {}\n\n  // 静态方法\n  static coding() {}\n}\n// 静态属性\nPerson.age = 0\n\nconsole.log(Person.age)\n```\n\n- 类继承：\n  - 1 如果子类提供了 constructor，那么，必须要调用`super()`\n  - 2 子类添加属性，必须在 super() 调用后面\n\n```javascript\n// 类继承：\nclass Chinese extends Person {\n  constructor(name, gender, weight) {\n    super(name, gender)\n\n    this.weight = weight\n  }\n}\n\nconst ch = new Chinese('小明', '男', 130)\n```\n\n### 静态属性和实例属性\n\n- 静态属性：直接通过类名访问\n- 实例属性：通过实例对象访问\n\n## ES6模块化 - import和export\n\n- [导入和导出](http://blog.csdn.net/DeepLies/article/details/52916221?locationNum=13&fps=1)\n- `import`：导入模块\n- `export`：导出模块\n\n- 注意1：`export default` 每个模块只能使用一次\n- 注意2：`export` 每个模块可以使用多次\n- 注意3：一个模块可以导出多个内容，`export default` 和 `export` 可以一起使用\n\n```javascript\n// main.js\n// 导入 default 内容，可自定义导入名称\n// import num from './a.js'\nimport num1 from './a.js'\n\n// a.js\nconst num = 123\nexport default num\n```\n\n```javascript\n// main.js\n// 导入 export内容\n// 注意：导入非default模块内容（str、fn），必须与 导出名称 相同，或者通过 as 修改\n// 注意：必须使用花括号\nimport { str, fn } from './b'\n\n// 加载并修改变量名\n// import { str as str1, fn } from './b'\n// 整体加载\n// import * as bModule from './b'\n\n// b.js\nexport const str = 'abc'\nexport function fn() {}\n```\n\n```javascript\n// main.js\nimport { str, fn } from './b'\n\n// b.js\nconst str = 'abc'\nfunction fn() {}\n// 一次性导出\nexport { str, fn }\n```\n\n## 数组扩展运算符\n\n- 扩展运算符（spread）是三个点（...）。作用：将一个数组转为用逗号分隔的参数序列\n\n```javascript\nvar arr = ['a', 'b', 'c']\nconsole.log(...arr)\n\n// 上面这句代码相当于：\nconsole.log(arr[0], arr[1], arr[2]);\n```\n\n## 对象扩展运算符\n\n- 注意：该语法不是真正的ES规范，需要使用`stage-2`解析\n\n```javascript\nvar obj = {name: 'jack', age: 19}\nvar o = {...obj, gender: 'male'}\n// o => {name: 'jack', age: 19, gender: 'male'}\n```\n\n## Promise 异步编程\n\n- [ES6 - Promise](http://es6.ruanyifeng.com/#docs/promise)\n- Promise是一种对尚未返回的数据的一种承诺\n- `promise`：承诺、保证\n\n### 介绍\n\n```markup\nPromise 是异步编程的一种解决方案，比传统的解决方案`回调函数和事件`更合理和更强大\nPromise 将异步操作以同步操作（链式编程）的流程表达出来，避免了层层嵌套的回调函数（回调地狱的问题）\n```\n\n- 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。\n\n- Promise对象代表一个异步操作，有三种状态：**pending（进行中）**、**fulfilled（已成功）**和**rejected（已失败）**\n  - 状态改变 1：pending -> fufilled\n  - 状态改变 2：pending -> rejected\n  - **一旦状态改变，就不会再变**\n\n### 基本使用\n\n```javascript\n// Promise 是一个构造函数\n// 通过 new 创建Promise的实例对象\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */) {\n    resolve(value)\n  } else {\n    reject(error)\n  }\n})\n```\n\n### then 和 catch\n\n- `then()`： 用于指定异步操作成功时的回调函数\n- `catch()`：用于指定发生错误时的回调函数\n- 说明：`then()`方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个then\n\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n  console.log('1 Promise');\n  // 异步操作\n  setTimeout(resolve, 1000, 'done');\n});\n\npromise.then(function() {\n  console.log('3 resolved.');\n});\n\nconsole.log('2 Hi!');\n```\n\n- 异步读取图片示例：\n\n```javascript\nconst loadImageAsync = function(url) {\n  return new Promise(function(resolve, reject) {\n    const image = new Image()\n    image.src = url\n\n    // 图片加载成功\n    image.onload = function() {\n      resolve(image)\n    }\n\n    // 图片加载失败\n    image.onerror = function() {\n      reject(new Error('Could not load image at ' + url))\n    }\n  })\n}\n\n// 推荐方式：\nloadImageAsync('url')\n  // 成功处理\n  .then(function(value) {})\n  // 错误处理\n  .catch(function(err) {})\n\n// 其他方式：\nloadImageAsync('url')\n  .then(function(value) {\n    // 成功，value 获取到 图片对象（image）\n  }, function(error) {\n    // 失败，error 获取到 错误信息\n  });\n```\n\n### all 和 race\n\n```javascript\n// 所有请求发送成功：\nconst p = Promise.all([\n  axios('http://vue.studyit.io/api/getlunbo'),\n  axios('http://vue.studyit.io/api/getnewslist')\n])\n\np.then(function (res) {\n  // res 是 all() 方法中所有异步操作的结果\n  console.log('两个异步请求完成：', res);\n})\n\n// 哪个请求先发送成功：\nconst p = Promise.race([\n  axios('http://vue.studyit.io/api/getlunbo'),\n  axios('http://vue.studyit.io/api/getnewslist')\n])\n\np.then(function (res) {\n  // res 是 race() 方法中先完成的异步操作的结果：\n  console.log('一个异步请求完成：', res);\n})\n```","fields":{"slug":"/ES6常用内容介绍/"},"frontmatter":{"title":"ES6常用内容介绍","date":"January 22, 2018","description":"ES6的普及度越来越高，本文主要介绍ES6中最常见的内容及其使用方式。","categories":["技术文章"],"tags":["JavaScript","ES6"],"toc":null}}},"pageContext":{"slug":"/ES6常用内容介绍/","previous":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/CentOS终端中文乱码的解决方案.md"},"fields":{"slug":"/CentOS终端中文乱码的解决方案/"},"frontmatter":{"title":"CentOS终端中文乱码的解决方案"}},"next":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/终端特殊字符实现清屏和颜色控制等操作.md"},"fields":{"slug":"/终端特殊字符实现清屏和颜色控制等操作/"},"frontmatter":{"title":"终端特殊字符实现清屏和颜色控制等操作"}},"frontmatter":{"title":"ES6常用内容介绍","date":"2018-01-22T23:00:23.284Z","tags":["JavaScript","ES6"],"categories":["技术文章"],"description":"ES6的普及度越来越高，本文主要介绍ES6中最常见的内容及其使用方式。"}}},"staticQueryHashes":["2786614800","3000541721","3828236571"],"slicesMap":{}}