{"componentChunkName":"component---src-templates-blog-post-tsx-content-file-path-content-blog-深入了解-vue-js源码-2-init-mixin-md","path":"/深入了解Vue-js源码-2-initMixin/","result":{"data":{"site":{"siteMetadata":{"title":"Wizard's Lair","postCopyright":true,"siteUrl":"https://wizd.dev","author":{"name":"w1zd"}}},"mdx":{"id":"1059cfb7-5448-5b43-ac49-35bb1bc4c163","excerpt":"构造函数中调用的  是在哪里定义的呢？正如我们所看到的，构造函数内部并未对这个  方法进行定义。 快速进行全局搜索源码可以发现  方法是在名为  的函数中添加到  上的。 initMixin\n\n 方法被定义在  函数中。 函数在  构造函数定义之后，和其他一组函数一起立即就被调用了，而且这一组函数调用全部接收了  构造函…","body":"\n构造函数中调用的 `this._init` 是在哪里定义的呢？正如我们所看到的，构造函数内部并未对这个 `._init` 方法进行定义。\n快速进行全局搜索源码可以发现 `._init` 方法是在名为 `initMixin` 的函数中添加到 `Vue.prototype` 上的。\n\n## initMixin\n\n`this._init` 方法被定义在 `initMixin` 函数中。`initMixin` 函数在 `Vue` 构造函数定义之后，和其他一组函数一起立即就被调用了，而且这一组函数调用全部接收了 `Vue` 构造函数作为实参。\n\n```javascript\n  function Vue (options) {\n    if (!(this instanceof Vue)\n    ) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n```\n\n我们来看一下 `initMixin` 函数的定义，特别简单，接收 `Vue` 构造函数作为形参，并且为构造函数原型添加了 `_init` 方法。\n\n```javascript\n  function initMixin (Vue) {\n    Vue.prototype._init = function (options) {\n      [. . . .]\n    };\n  }\n```\n\n## `uid$3`\n\n在顶级作用域中， `initMixin` 上面定义了一个变量 `uid$3`，这个变量被当做一个计数器，每当创建一个 `Vue` 实例的时候，都会自增，然后添加为当次创建的 `Vue` 实例的属性。\n\n```javascript\n  function initMixin (Vue) {\n    Vue.prototype._init = function (options) {\n      // a uid\n      vm._uid = uid$3++;\n      [. . . .]\n    };\n  }\n```\n\n## `vm` 和 `this`\n\n在 `_init` 方法内部设置了一个 `this` 的帮助变量。通常情况下，我们会将代表当前函数上下文对象的 `this` 关键字保存在其他变量中，方便以后使用，比如 `self = this`。 这里的做法是类似的，将 `this` 保存在了一个名为 `vm` 的变量中：\n\n```javascript\n  function initMixin (Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      [. . . .]\n    };\n  }\n```\n\n## 性能相关\n\n接下来，`._init`方法中，设置了性能检查相关的内容。\n\n```javascript\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    ...\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n    ...\n  }\n}\n```\n\n这里声明了两个变量 `startTag` 和 `endTag`.\n\n```javascript\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    [. . . .]\n    var startTag, endTag;\n    [. . . .]\n  }\n}\n```\n\n然后你可能会注意到这个奇怪的注释：\n\n```javascript\n/* istanbul ignore if */\n```\n\n[`Istanbul`](https://github.com/gotwarlost/istanbul) 其实是一个覆盖率测试工具，这里的注释是在告诉 `Istanbul` 忽略掉 `if` 语句。\n\n`if` 语句首先检查的是当前环境是开发环境还是生产环境，然后判断 `config.performence` 属性是否有设置为 `true`。\n\n```javascript\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    [. . . .]\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    }\n    [. . . .]\n  }\n}\n```\n\n### `config` 对象\n\n这里我们不得不去关注一下 `config` 这个对象，这个对象声明在别的地方，并且默认的 `performance` 这个属性是 `false`。\n\n```javascript\nvar config = ({\n  [. . . .]\n    /**\n   * Whether to record perf\n   */\n  performance: false,\n  [. . . .]\n})\n```\n\n就像注释标记的那样，`config.performance` 这个属性用来决定 `Vue` 是否要记录性能。\n\n我们继续回到 `_init` 方法里面来，`if` 语句中接下来又检查了一个名为 `mark` 的变量。\n\n```javascript\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    [. . . .]\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    }\n    [. . . .]\n  }\n}\n```\n\n### `mark` 函数\n\n那我们又不得不去找找看 `mark` 到底是在哪儿定义的。\n\n```javascript\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (\n      perf &&\n      perf.mark &&\n      perf.measure &&\n      perf.clearMarks &&\n      perf.clearMeasures\n    ) {\n      mark = function (tag) { return perf.mark(tag); };\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        // perf.clearMeasures(name)\n      };\n    }\n  }\n```\n\n查看代码我们会发现，这个`mark`变量，只会在特定的情况下被赋值。首先呢，他会检查，我们是否在浏览器环境中，然后检查 `window.performance` 是否存在。\n\n```javascript\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  [. . . .]\n  {\n    var perf = inBrowser && window.performance;\n    [. . . .]\n  }\n```\n\n要知道这里在干吗，我们需要去文档查看一下 `window` 对象的 `performance` 属性。 MDN中说: \n> “`window` 对象的 `performance` 属性返回一个 `Performance` 对象，可用于收集当前文档的性能信息。 它作为 `Performance Timeline API`，`High Resolution Time API`，`Navigation Timing API`，`User Timing API`和`Resource Timing API`的公开点。性能接口是`High Resolution Time API`的一部分，可以通过它来访问当前页面性能相关信息。\n\n`mark`, `measure`, `clearMarks`, `clearMeasures` 都是 `Performance` 对象上的方法。\n\n* `mark` 方法用给定的名字在浏览器的性能输入缓冲区创建一个时间戳。\n\n* `measure` 方法在浏览器的性能输入缓冲区中两个指定标记(分别称为开始标记和结束标记)之间创建一个命名时间戳。\n\n* `clearMarks` 方法用来移除浏览器的性能输入缓冲区中指定的 `mark`\n  \n* `clearMeasures` 方法用来移除浏览器的性能输入缓冲区中指定的 `measure`\n\n就像Vue [API](https://vuejs.org/v2/api/#performance)中解释的那样，如果 `performance` 选项被设置为 `true`，将会在浏览器的 `devtool peformance/timeline` 面板中开启对组件初始化、编译、渲染以及组件更新的性能追踪。但是只能在`development` 模式下生效，并且受限于浏览器，只能在支持 `performance.mark` 接口的浏览器中使用。\n\n所以，我们继续回头看一下 `mark` 变量的初始化代码：\n\n```javascript\n{\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n```\n\n如果 `perf` 对象存在，并且当 `perf` 对象中存在 `mark`、 `measure`、 `clearMarks` 和 `clearMeasures` 方法，那么 Vue 就会设置好 `mark` 和 `measure` 函数。\n\n`mark` 函数接收一个 `tag` 作为形参，并且返回一个在浏览器性能入口缓存区中用 `tag` 作为名字的时间戳。\n\n`mark` 与 `measure` 一起，就允许我们在浏览器 `devtool perfomance/timeline` 面板中跟踪性能。\n\n### 继续回到`_init`方法\n\n现在我们知道了 `mark` 函数是用来做什么的，我们终于可以继续回到 `Vue.prototype._init` 方法中继续了解代码所做的事情。\n\n下面的代码，检查了是否是开发环境，确认了性能配置选项是否被设置为 `true`, 还确认了 `mark` 函数是否存在。如果上述三个检查都通过了，Vue 会设置两个变量 `startTag` 和 `endTag`, 然后使用 `startTag` 作为形参调用 `mark` 函数。\n\n```javascript\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n    [. . . .]\n  }\n}\n```","fields":{"slug":"/深入了解Vue-js源码-2-initMixin/"},"frontmatter":{"title":"深入了解Vue.js源码(#2-initMixin-part1)","date":"August 02, 2019","description":"本系列文章详细介绍了Vue.js源代码，对其中的JavaScript代码进行了详细的说明。 并且尝试将概念分解为JavaScript初学者可以理解的水平。","categories":["技术文章"],"tags":["Vue"],"toc":true}}},"pageContext":{"slug":"/深入了解Vue-js源码-2-initMixin/","previous":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/前端技能路线图-2019.md"},"fields":{"slug":"/前端技能路线图-2019/"},"frontmatter":{"title":"前端技能路线图-2019"}},"next":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/给新手看的React-Hooks教程.md"},"fields":{"slug":"/给新手看的React-Hooks教程/"},"frontmatter":{"title":"给新手看的 React Hooks 教程"}},"frontmatter":{"title":"深入了解Vue.js源码(#2-initMixin-part1)","date":"2019-08-02T16:06:08.284Z","tags":["Vue"],"categories":["技术文章"],"description":"本系列文章详细介绍了Vue.js源代码，对其中的JavaScript代码进行了详细的说明。 并且尝试将概念分解为JavaScript初学者可以理解的水平。","toc":true}}},"staticQueryHashes":["2786614800","3000541721","3828236571"],"slicesMap":{}}