{"componentChunkName":"component---src-templates-blog-post-tsx-content-file-path-content-blog-java-script深拷贝实现-md","path":"/JavaScript深拷贝实现/","result":{"data":{"site":{"siteMetadata":{"title":"Wizard's Lair","postCopyright":true,"siteUrl":"https://wizd.dev","author":{"name":"w1zd"}}},"mdx":{"id":"c466087b-c3c9-560f-97b9-5d6e193772ce","excerpt":"在实际开发当中，我们经常会遇到要对对象进行深拷贝的情况。而且深拷贝这个问题在面试过程中也经常会遇到，下面就对本人在学习过程中的收获，做以简单的总结。 什么是浅拷贝，什么是深拷贝？\n什么是浅拷贝\n\n关于浅拷贝的概念，我在网上看到一种说法，直接上代码。\n\n但是我个人认为，上面这个根本不涉及拷贝，只是一个简单的引用赋值…","body":"\n在实际开发当中，我们经常会遇到要对对象进行深拷贝的情况。而且深拷贝这个问题在面试过程中也经常会遇到，下面就对本人在学习过程中的收获，做以简单的总结。\n\n## 什么是浅拷贝，什么是深拷贝？\n### 什么是浅拷贝\n关于浅拷贝的概念，我在网上看到一种说法，直接上代码。\n```javascript\nvar person = {name: \"Jason\", age: 18, car: {brand: \"Ferrari\", type: \"430\"}};\nvar person1 = person; \t\t//他们认为这是浅拷贝\n```\n但是我个人认为，上面这个根本不涉及拷贝，只是一个简单的引用赋值。以我的理解，浅拷贝应该是不考虑对象的引用类型的属性，只对当前对象的所有成员进行拷贝，代码如下：\n```javascript\nfunction copy(obj){\n\tvar objCopy = {};\n\tfor(var key in obj){\n\t\tobjCopy[key] = obj[key];\n\t}\n\treturn objCopy;\n}\n\nvar person = {name: \"Jason\", age: 18, car: {brand: \"Ferrari\", type: \"430\"}};\nvar personCopy = copy(person);\n```\n上面这段代码中，`person`对象拥有两个基本类型的属性`name`和`age`，一个引用类型的属性`car`，当使用如上方法进行拷贝的时候，`name`和`age`属性会被正常的拷贝，但是`car`属性，只会进行引用的拷贝，这样会导致拷贝出来的对象`personCopy`和`person`会共用一个`car`对象。这样就是所谓的浅拷贝。\n\n### 什么是深拷贝\n\n深拷贝的就是在拷贝的时候，需要将当前要拷贝的对象内的所有引用类型的属性进行完整的拷贝，也就是说拷贝出来的对象和原对象之间没有任何数据是共享的，所有的东西都是自己独占的一份。\n\n## 如何实现深拷贝\n### 实现深拷贝需要考虑的问题\n实现深拷贝需要考虑如下几个因素：\n* 传入的对象是使用对象字面量`{}`创建的对象还是由构造函数生成的对象\n* 如果对象是由构造函数创建出来的，那么是否要拷贝原型链上的属性\n* 如果要拷贝原型链上的属性，那么如果原型链上存在多个同名的属性，保留哪个\n* 处理循环引用的问题\n\n### 第三方库实现深拷贝\n\n#### jQuery的$.extend()\n我们可以通过`$.extend()`方法来完成深复制。值得庆幸的是，我们在`jQuery`中可以通过添加一个参数来实现递归`extend`。调用`$.extend(true, {}, ...)`就可以实现深复制，参考下面的例子:\n```javascript\nvar x = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [ 1, 2, 3 ]\n};\n\nvar y = $.extend({}, x),          //shallow copy\n    z = $.extend(true, {}, x);    //deep copy\n\ny.b.f === x.b.f       // true\nz.b.f === x.b.f       // false\n```\n\n但是jQuery的这个`$.extend()`方法，有弊端，什么弊端呢？我们看下面的例子：\n```javascript\nvar objA = {};\nvar objB = {};\n\nobjA.b = objB;\nobjB.a = objA;\n\n$.extend(true,{},a);\n\n//这个时候就出现异常了\n//Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n也就是说，jQuery中的`$.extend()`并没有处理循环引用的问题。\n\n### 使用JSON对象实现深拷贝\n使用`JSON`全局对象的`parse`和`stringify`方法来实现深复制也算是一个简单讨巧的方法。\n```javascript\nfunction jsonClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nvar clone = jsonClone({ a:1 });\n```\n\n然而使用这种方法会有一些隐藏的坑，它能正确处理的对象只有 `Number`, `String`, `Boolean`, `Array`, 扁平对象，即那些能够被 json 直接表示的数据结构。\n\n\n### 自己造轮子\n下面我们给出一个简单的解决方案，当然这个方案是参考别人的方式来实现的。希望对大家有用。\n\n```javascript\nvar clone = (function() {\n\t//这个方法用来获取对象的类型 返回值为字符串类型 \"Object RegExp Date Array...\"\n\tvar classof = function(o) {\n\t\tif (o === null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tif (o === undefined) {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\t// 这里的Object.prototype.toString很可能用的就是Object.prototype.constructor.name\n\t\t// 这里使用Object.prototype.toString来生成类型字符串\n\t\tvar className = Object.prototype.toString.call(o).slice(8, -1);\n\t\treturn className;\n\t};\n\n\t//这里这个变量我们用来存储已经保存过的属性，目的在于处理循环引用的问题\n\tvar references = null;\n\n\t//遇到不同类型的对象的处理方式\n\tvar handlers = {\n\t\t//正则表达式的处理\n\t\t'RegExp': function(reg) {\n\t\t\tvar flags = '';\n\t\t\tflags += reg.global ? 'g' : '';\n\t\t\tflags += reg.multiline ? 'm' : '';\n\t\t\tflags += reg.ignoreCase ? 'i' : '';\n\t\t\treturn new RegExp(reg.source, flags);\n\t\t},\n\t\t//时间对象处理\n\t\t'Date': function(date) {\n\t\t\treturn new Date(+date);\n\t\t},\n\t\t//数组处理 第二个参数为是否做浅拷贝\n\t\t'Array': function(arr, shallow) {\n\t\t\tvar newArr = [],\n\t\t\ti;\n\t\t\tfor (i = 0; i < arr.length; i++) {\n\t\t\t\tif (shallow) {\n\t\t\t\t\tnewArr[i] = arr[i];\n\t\t\t\t} else {\n\t\t\t\t\t//这里我们通过reference数组来处理循环引用问题\n\t\t\t\t\tif (references.indexOf(arr[i]) !== -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar handler = handlers[classof(arr[i])];\n\t\t\t\t\tif (handler) {\n\t\t\t\t\t\treferences.push(arr[i]);\n\t\t\t\t\t\tnewArr[i] = handler(arr[i], false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewArr[i] = arr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newArr;\n\t\t},\n\t\t//正常对象的处理 第二个参数为是否做浅拷贝\n\t\t'Object': function(obj, shallow) {\n\t\t\tvar newObj = {}, prop, handler;\n\t\t\tfor (prop in obj) {\n\t\t\t\t//关于原型中属性的处理太过复杂，我们这里暂时不做处理\n\t\t\t\t//所以只对对象本身的属性做拷贝\n\t\t\t\tif (obj.hasOwnProperty(prop)) {\n\t\t\t\t\tif (shallow) {\n\t\t\t\t\t\tnewObj[prop] = obj[prop];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//这里还是处理循环引用的问题\n\t\t\t\t\t\tif (references.indexOf(obj[prop]) !== -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\thandler = handlers[classof(obj[prop])];\n\t\t\t\t\t\t//如果没有对应的处理方式，那么就直接复制\n\t\t\t\t\t\tif (handler) {\n\t\t\t\t\t\t\treferences.push(obj[prop]);\n\t\t\t\t\t\t\tnewObj[prop] = handler(obj[prop], false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewObj[prop] = obj[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newObj;\n\t\t}\n\t};\n\n\treturn function(obj, shallow) {\n\t\t//首先重置我们用来处理循环引用的这个变量\n\t\treferences = [];\n\t\t//我们默认处理为浅拷贝\n\t\tshallow = shallow === undefined ? true : false;\n\t\tvar handler = handlers[classof(obj)];\n\t\treturn handler ? handler(obj, shallow) : obj;\n\t};\n}());\n\n(function() {\n\t//下面是一些测试代码\n\tvar date = new Date();\n\tvar reg = /hello word/gi;\n\tvar obj = {\n\t\tprop: 'this ia a string',\n\t\tarr: [1, 2, 3],\n\t\to: {\n\t\t\twow: 'aha'\n\t\t}\n\t};\n\tvar refer1 = {\n\t\tarr: [1, 2, 3]\n\t};\n\tvar refer2 = {\n\t\trefer: refer1\n\t};\n\trefer1.refer = refer2;\n\n\tvar cloneDate = clone(date, false);\n\tvar cloneReg = clone(reg, false);\n\tvar cloneObj = clone(obj, false);\n\talert((date !== cloneDate) && (date.valueOf() === cloneDate.valueOf()));\n\talert((cloneReg !== reg) && (reg.toString() === cloneReg.toString()));\n\talert((obj !== cloneObj) && (obj.arr !== cloneObj.arr) && (obj.o !== cloneObj.o) && (JSON.stringify(obj) === JSON.stringify(cloneObj)));\n\n\tclone(refer2, false);\n\talert(\"I'm not dead yet!\");\n\t// Output:\n\t// true\n\t// true\n\t// true\n\t// I'm not dead yet!\n}());\n```\n","fields":{"slug":"/JavaScript深拷贝实现/"},"frontmatter":{"title":"JavaScript深拷贝实现","date":"October 08, 2016","description":"深拷贝和浅拷贝在很多语言中都会涉及到，在JavaScript当中，没有现成的可以直接实现深拷贝的方法，虽然我们可以使用jQuery当中提供的`extend`方法，但是这个方法有一定的局限性，所以本文主要研究JavaScript当中深拷贝的实现。","categories":["技术文章"],"tags":["JavaScript","Front-end"],"toc":true}}},"pageContext":{"slug":"/JavaScript深拷贝实现/","previous":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/CentOS-7-Shadowsocks-安装.md"},"fields":{"slug":"/CentOS-7-Shadowsocks-安装/"},"frontmatter":{"title":"CentOS 7 Shadowsocks 安装"}},"next":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/CentOS安装Node-js.md"},"fields":{"slug":"/CentOS安装Node-js/"},"frontmatter":{"title":"CentOS安装Node.js"}},"frontmatter":{"title":"JavaScript深拷贝实现","date":"2016-10-08T19:02:29.284Z","tags":["JavaScript","Front-end"],"categories":["技术文章"],"description":"深拷贝和浅拷贝在很多语言中都会涉及到，在JavaScript当中，没有现成的可以直接实现深拷贝的方法，虽然我们可以使用jQuery当中提供的`extend`方法，但是这个方法有一定的局限性，所以本文主要研究JavaScript当中深拷贝的实现。","toc":true}}},"staticQueryHashes":["2786614800","3000541721","3828236571"],"slicesMap":{}}