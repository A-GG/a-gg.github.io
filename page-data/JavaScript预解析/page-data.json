{"componentChunkName":"component---src-templates-blog-post-tsx-content-file-path-content-blog-java-script预解析-md","path":"/JavaScript预解析/","result":{"data":{"site":{"siteMetadata":{"title":"Wizard's Lair","postCopyright":true,"siteUrl":"https://wizd.dev","author":{"name":"w1zd"}}},"mdx":{"id":"e1b4bd21-177e-5cc9-aacd-c060c907be27","excerpt":"JavaScript是解释型的语言，但是他并不是真的在运行的时候逐句的往下解析执行。 我们来看下面这个例子：\n\n在上面这段代码中，函数func的调用是在其声明之前，如果说JavaScript代码真的是逐句的解析执行，那么在第一句调用的时候就会出错，然而事实并非如此，上面的代码可以正常执行，并且alert出来。\n\n所以…","body":"JavaScript是解释型的语言，但是他并不是真的在运行的时候逐句的往下解析执行。\n\n我们来看下面这个例子：\n\n```javascript\nfunc();\n\nfunction func(){\n    alert(\"Funciton has been called\");\n}\n```\n在上面这段代码中，函数func的调用是在其声明之前，如果说JavaScript代码真的是逐句的解析执行，那么在第一句调用的时候就会出错，然而事实并非如此，上面的代码可以正常执行，并且alert出来`Function has been called`。\n\n**所以，可以得出结论，JavaScript并非仅在运行时简简单单的逐句解析执行！**\n\n## JavaScript 预解析\nJavaScript引擎在对JavaScript代码进行解释执行之前，会对JavaScript代码进行预解析，在预解析阶段，会将以关键字`var`和`function`开头的语句块提前进行处理。\n\n*关键问题是怎么处理呢？*\n\n当变量和函数的声明处在作用域比较靠后的位置的时候，变量和函数的声明会被提升到作用域的开头。\n\n重新来看上面的那段代码\n```javascript\nfunc();\n\nfunction func(){\n    alert(\"Funciton has been called\");\n}\n```\n由于JavaScript的预解析机制，上面的代码就等效于：\n```javascript\nfunction func(){\n    alert(\"Funciton has been called\");\n}\n\nfunc();\n```\n看完函数声明的提升，再来看一个变量声明提升的例子：\n```javascript\nalert(a);\nvar a = 1;\n```\n由于JavaScript的预解析机制，上面这段代码，alert出来的值是`undefined`，如果没有预解析，代码应该会直接报错`a is not defined`，而不是输出值。\n\nWait a minute, 不是说要提前的吗？那不是应该alert出来1，为什么是`undefined`?\n\n那么在这里有必要说一下`声明`、`定义`、`初始化`的区别。其实这几个概念是C系语言的人应该都比较了解的。\n\n| 行为 | 说明 |\n|--|--|\n|声明|告诉编译器/解析器有这个变量存在,这个行为是不分配内存空间的,在JavaScript中，声明一个变量的操作为：`var a;`|\n|定义|为变量分配内存空间，在C语言中，一般声明就包含了定义，比如：`int a;`,但是在JavaScript中，`var a;`这种形式就只是声明了。|\n|初始化|在定义变量之后，系统为变量分配的空间内存储的值是不确定的，所以需要对这个空间进行初始化，以确保程序的安全性和确定性|\n|赋值|赋值就是变量在分配空间之后的某个时间里，对变量的值进行的刷新操作（修改存储空间内的数据)|\n\n所以我们说的提升，是**声明**的提升。\n\n那么再回过头看，上面的代码就等效于：\n```javascript\nvar a; //这里是声明\nalert(a);//变量声明之后并未有初始化和赋值操作，所以这里是 undefined\na = 1;\n```\n\n## 复杂点的情况分析\n通过上一小节的内容，我们对变量、函数声明提升已经有了一个最基本的理解。那么接下来，我们就来分析一些略复杂的情况。\n\n### 函数同名\n观察下面这段代码:\n```javascript\nfunc1();\nfunction func1(){\n    console.log('This is func1');\n}\n\nfunc1();\nfunction func1(){\n    console.log('This is last func1');\n}\n```\n输出结果为：\n```bash\nThis is last func1\nThis is last func1\n```\n原因分析：由于预解析机制，`func1`的声明会被提升，提升之后的代码为：\n```javascript\nfunction func1(){\n    console.log('This is func1');\n}\nfunction func1(){\n    console.log('This is last func1');\n}\nfunc1();\nfunc1();\n```\n同名的函数，后面的会覆盖前面的，所以两次输出结果都是`This is last func1`。\n\n### 变量和函数同名\n```javascript\nalert(foo); \nfunction foo(){}\nvar foo = 2;\n```\n当出现变量声明和函数同名的时候，只会对函数声明进行提升，变量会被忽略。所以上面的代码的输出结果为\n```javascript\nfunction foo(){}\n```\n我们还是来吧预解析之后的代码展现出来:\n```javascript\nfunction foo(){};\nalert(foo);\nfoo = 2;\n```\n再来看一种\n```javascript\nvar num = 1;\nfunction num () {\n    alert( num );\n}\nnum();\n```\n代码执行结果为：\n```\nUncaught TypeError: num is not a function\n```\n直接上预解析后的代码：\n```javascript\nfunction num(){\n    alert(num);\n}\nnum = 1;\nnum();\n```\n\n## 预解析是分作用域的\n声明提升并不是将所有的声明都提升到window对象下面，提升原则是提升到变量运行的环境(作用域)中去。\n\n```javascript\nfunction showMsg() \n{ \n    var msg = 'This is message'; \n} \nalert(msg); // msg未定义\n```\n\n还是直接把预解析之后的代码写出来：\n```javascript\nfunction showMsg() \n{ \n    var msg;\n    msg = 'This is message'; \n} \nalert(msg); // msg未定义\n```\n\n## 预解析是分段的\n分段，其实就分script标签的\n```markup\n<script>\nfunc();  // 输出 AA2;\nfunction func(){\n    console.log('AA1');\n}\n\nfunction func(){\n    console.log('AA2');\n}\n</script>\n\n\n<script>\nfunction func(){\n    console.log('AA3');\n}\n</script>\n\n```\n在上面代码中，第一个script标签中的两个`func`进行了提升，第二个`func`覆盖了第一个`func`，但是第二个script标签中的`func`并没有覆盖上面的第二个`func`。所以说预解析是分段的。\n\ntip:但是要注意，分段只是单纯的针对函数，变量并不会分段预解析。\n\n## 函数表达式并不会被提升\n```javascript\nfunc();\nvar func = function(){\n    alert(\"我被提升了\");\n};\n```\n这里会直接报错，`func is not a function`，原因就是函数表达式，并不会被提升。只是简单地当做变量声明进行了处理，如下：\n```javascript\nvar func;\nfunc();\nfunc = function(){\n    alert(\"我被提升了\");\n}\n```\n\n## 条件式函数声明\n```javascript\nconsole.log(typeof func);\nif(true){\n    function(){\n        return 1;\n    }\n}\nconsole.log(typeof func);\n```\n上面这段代码，就是所谓的条件式函数声明，这段代码在Gecko引擎中打印`\"undefined\"`、`\"function\"`；而在其他浏览器中则打印`\"function\"`、`\"function\"`。\n\n原因在于Gecko加入了ECMAScript以外的一个feature：条件式函数声明。\n>Conditionally created functions Functions can be conditionally declared, that is, a function declaration can be nested within an if statement.\n\n\n>Note: Although this kind of function looks like a function declaration, it is actually an expression (or statement), since it is nested within another statement. See differences between function declarations and function expressions.\n\nNote中的文字说明，条件式函数声明的处理和函数表达式的处理方式一样，所以条件式函数声明没有声明提升的特性。\n\n\n","fields":{"slug":"/JavaScript预解析/"},"frontmatter":{"title":"JavaScript预解析","date":"September 19, 2016","description":"本文主要记录JavaScript中的预解析机制，以及在预解析机制中，需要注意的一些问题。","categories":["技术文章"],"tags":["JavaScript"],"toc":true}}},"pageContext":{"slug":"/JavaScript预解析/","previous":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/CentOS7-iptables配置.md"},"fields":{"slug":"/CentOS7-iptables配置/"},"frontmatter":{"title":"CentOS7 iptables配置"}},"next":{"internal":{"contentFilePath":"/home/runner/work/w1zd.github.io/w1zd.github.io/content/blog/VPS架设OpenVPN服务器.md"},"fields":{"slug":"/VPS架设OpenVPN服务器/"},"frontmatter":{"title":"VPS架设OpenVPN服务器"}},"frontmatter":{"title":"JavaScript预解析","date":"2016-09-19T17:31:28.284Z","tags":["JavaScript"],"categories":["技术文章"],"description":"本文主要记录JavaScript中的预解析机制，以及在预解析机制中，需要注意的一些问题。","toc":true}}},"staticQueryHashes":["2786614800","3000541721","3828236571"],"slicesMap":{}}