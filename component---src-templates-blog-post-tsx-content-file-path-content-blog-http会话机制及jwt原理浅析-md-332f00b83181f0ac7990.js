"use strict";(self.webpackChunkw1zd_lair=self.webpackChunkw1zd_lair||[]).push([[8928],{624:function(e,n,a){a.r(n),a.d(n,{default:function(){return d}});var t=a(8453),l=a(6540);function s(e){const n=Object.assign({img:"img",h2:"h2",a:"a",span:"span",p:"p",h3:"h3",strong:"strong",em:"em",h4:"h4",ul:"ul",li:"li",h5:"h5",ol:"ol"},(0,t.RP)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.img,{src:"https://raw.githubusercontent.com/w1zd/image-hosting/main/img/2022/05/10/11-55-34-77f83fc49b81e4f8377846d66fa014ad-jwt-a0a11c.jpg",alt:"jwt"}),"\n",l.createElement(n.h2,{id:"http-协议无状态的说明马什么梅什么冬梅",style:{position:"relative"}},l.createElement(n.a,{href:"#http-%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E8%AF%B4%E6%98%8E%E9%A9%AC%E4%BB%80%E4%B9%88%E6%A2%85%E4%BB%80%E4%B9%88%E5%86%AC%E6%A2%85","aria-label":"http 协议无状态的说明马什么梅什么冬梅 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"HTTP 协议无状态的说明（马什么梅？什么冬梅？）"),"\n",l.createElement(n.p,null,"HTTP 协议属于无状态协议，在客户端使用 HTTP 协议与服务端通信的时候，服务器就像是马冬梅家楼下的老大爷一样，比较健忘。每次请求对于服务器来说都是一次全新的请求，对之前的请求毫无记忆。"),"\n",l.createElement(n.p,null,"如果不对此提供相应的解决方案，那么用户在访问网站的时候，页面每跳转一次就得输入一次用户名和密码来给服务器大爷表明身份，可以说用户体验极差。"),"\n",l.createElement(n.p,null,"那么实际开发中我们是如何解决上述问题的？"),"\n",l.createElement(n.h2,{id:"http-协议会话状态保持",style:{position:"relative"}},l.createElement(n.a,{href:"#http-%E5%8D%8F%E8%AE%AE%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81","aria-label":"http 协议会话状态保持 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"HTTP 协议会话状态保持"),"\n",l.createElement(n.p,null,"会话状态保持，指的就是让服务器对之前的请求有记忆，客户端在对服务器发起请求时便不需要每次都进行身份认证，一次登录身份信息一直有效，直至登出或者会话过期。"),"\n",l.createElement(n.p,null,"要实现这样的功能，最简单的方式就是服务器在对客户端进行身份认证之后，给客户端发放令牌，客户端在后续所有的请求中都携带该令牌，这样即可避免重复的身份校验，这里的令牌就像是古代出入皇宫用的令牌，是身份的标识。"),"\n",l.createElement(n.h3,{id:"cookie--session",style:{position:"relative"}},l.createElement(n.a,{href:"#cookie--session","aria-label":"cookie  session permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Cookie & Session"),"\n",l.createElement(n.p,null,"本节中不对 Cookie 和 Session 做详细讲解，只涉及会话保持相关内容。"),"\n",l.createElement(n.p,null,"我们可以简单的将 Session 理解为服务器端一小块存储空间，Cookie 为浏览器端的一小块存储空间。"),"\n",l.createElement(n.p,null,"用户正常的登录操作将会如下图所示："),"\n",l.createElement(n.img,{src:"https://raw.githubusercontent.com/w1zd/image-hosting/main/img/2022/05/10/11-55-56-9142b0e1e226be2566e792ecedc6291f-cookie-session-754c2e.jpg",alt:"cookie-session"}),"\n",l.createElement("div",{style:{display:"none"}},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="mermaid"><pre class="language-mermaid"><code class="language-mermaid"><span class="token keyword">sequenceDiagram</span>\n <span class="token keyword">participant</span> Cookie\n <span class="token keyword">participant</span> 客户端\n <span class="token keyword">participant</span> 服务器\n <span class="token keyword">participant</span> Session\n    客户端<span class="token arrow operator">-></span>服务器<span class="token operator">:</span> ① 登录请求：用户名&amp;密码\n    服务器<span class="token arrow operator">-></span>服务器<span class="token operator">:</span> ② 验证用户名和密码\n    服务器<span class="token arrow operator">-></span>Session<span class="token operator">:</span> ③ 通过校验后，将用户信息存储到Session中\n    Session<span class="token arrow operator">-></span>服务器<span class="token operator">:</span> ④ 获取到存储在Session中的信息对应的SessionId\n    服务器<span class="token arrow operator">-></span>客户端<span class="token operator">:</span> ⑤ 在响应头中使用Set-Cookie&lt;br />让客户端将Session存储到Cookie中\n    客户端<span class="token arrow operator">-></span>Cookie<span class="token operator">:</span> ⑥ 将SessionId存储到Cookie\n    Cookie<span class="token arrow operator">-></span>客户端<span class="token operator">:</span> ⑥ 所有的请求会自动将Cookie中的&lt;br />SessionId携带到服务器\n    客户端<span class="token arrow operator">-></span>服务器<span class="token operator">:</span> ⑦ 后续包含SessionId的请求\n    服务器<span class="token arrow operator">-></span>Session<span class="token operator">:</span> ⑧ 服务器拿到SessionId之后&lt;br />去Session中查找对应的信息&lt;br />找到就证明登录了，找不到就让用户重新登录</code></pre></div>'}})),"\n",l.createElement(n.h3,{id:"传统-token",style:{position:"relative"}},l.createElement(n.a,{href:"#%E4%BC%A0%E7%BB%9F-token","aria-label":"传统 token permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"传统 Token"),"\n",l.createElement(n.p,null,"其实早期 Token 的出现是为了解决单点登录中的 Session 问题以及移动端不能使用 Cookie 的问题的，他和上面提到的 SessionId 功效几乎完全一致。所以你可以把上图中的 SessionID 和 Token 划等号。"),"\n",l.createElement(n.p,null,"这里的 Token 一般都是在用户身份验证成功之后，生成的全局唯一的随机字符串(UUID)，用它作为键将必要信息以及 Token 有效期等信息存储到相关的数据库中，随后将其返回给客户端，客户端需要自行管理接收到的Token, 在后续的请求中，都需要携带这个 Token。在服务器接收到这个 Token 之后，查库验证 Token 的有效性。"),"\n",l.createElement(n.p,null,"和上面 Cookie & Session 差别在于，在使用 Token 的时候，服务端信息存储的位置不局限于 Session 空间，而可以使用 Redis/MongoDB 等NoSQL数据库做分布式存储，这使得鉴权性能以及稳定性都有提升。"),"\n",l.createElement(n.p,null,"注意，这里的 Token 只是一个单纯的通行证，此方式仍然需要在服务器端进行数据存储，随着用户数量的增长，服务器的开支也会随之增大。那么思考一下，如果 Token 本身就能携带信息，那么服务器端就不用再存储数据，是不是就解决了上述服务器储存开支的问题？"),"\n",l.createElement(n.h2,{id:"jwt",style:{position:"relative"}},l.createElement(n.a,{href:"#jwt","aria-label":"jwt permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"JWT"),"\n",l.createElement(n.p,null,"JWT（JSON Web Token) 可以算是一种规范化的 Token 身份认证方式，他规定了 Token 中携带信息的方式。"),"\n",l.createElement(n.p,null,"JWT 同样也是服务端在对用户身份验证之后生成 Token，然后颁发给客户端，和普通 Token 不同的是，JWT 中可以携带该 Token 相关的信息，这样服务器端就不再需要额外的存储空间了，服务端在接受到客户端请求的时候，只需要通过 Token 自身携带的信息进行有效性校验即可。"),"\n",l.createElement(n.h3,{id:"jwt-使用",style:{position:"relative"}},l.createElement(n.a,{href:"#jwt-%E4%BD%BF%E7%94%A8","aria-label":"jwt 使用 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"JWT 使用"),"\n",l.createElement(n.p,null,"客户端通过身份验证之后从服务器端获取到的 JWT 可能是这样的："),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http">eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9\n.\neyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n.\ndBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</code></pre></div>'}}),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,l.createElement(n.em,null,"注意： 这里的为了方便大家看清格式，我将原本的单行文本进行了换行，实际获取到的 JWT 是没有换行的。"))),"\n",l.createElement(n.p,null,"在获取到 JWT 之后，后续的请求需要将获取到的 Token 以 Authorization 为键添加到请求头中:"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="http"><pre class="language-http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Authorization</span><span class="token punctuation">:</span><span class="token header-value">Bearer 你的token</span></span></code></pre></div>'}}),"\n",l.createElement(n.p,null,"比如 axios 默认请求头设置："),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript">axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"Authorization"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Bearer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>token<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span></code></pre></div>'}}),"\n",l.createElement(n.h3,{id:"jwt-是如何生成的",style:{position:"relative"}},l.createElement(n.a,{href:"#jwt-%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84","aria-label":"jwt 是如何生成的 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"JWT 是如何生成的？"),"\n",l.createElement(n.p,null,"实际开发中已经有很多现成的库可以帮我们处理 JWT 相关的内容，比如生成 JWT 以及验证 JWT。所以这节内容中我们不涉及具体代码，只给大家分享 JWT 的工作原理。"),"\n",l.createElement(n.h4,{id:"jwt-的结构",style:{position:"relative"}},l.createElement(n.a,{href:"#jwt-%E7%9A%84%E7%BB%93%E6%9E%84","aria-label":"jwt 的结构 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"JWT 的结构"),"\n",l.createElement(n.p,null,"一个 JWT 中包含有三部分，中间用 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.</code>'}})," 隔开："),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"header：使用 base64 处理过的 Token Meta。（",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">base64(header)</code>'}}),"）"),"\n",l.createElement(n.li,null,"payload：使用 base64 处理过的实际携带的数据。（",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">base64(payload)</code>'}}),"）"),"\n",l.createElement(n.li,null,"signature: 使用 HMACSHA256 从 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">header</code>'}})," ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">paylaod</code>'}})," 提取。（",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:"<code class=\"language-text\">HMACSHA256(header + '.' + paylaod, '秘钥')</code>"}}),"）"),"\n"),"\n",l.createElement(n.h5,{id:"header",style:{position:"relative"}},l.createElement(n.a,{href:"#header","aria-label":"header permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Header"),"\n",l.createElement(n.p,null,"包含在 Header 中的 Token Meta 通常由两部分组成：令牌的类型（即 JWT），以及所使用的签名算法，如 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">HMAC SHA256</code>'}})," 或 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">RSA</code>'}}),"。"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"alg"</span><span class="token operator">:</span> <span class="token string">"HS256"</span><span class="token punctuation">,</span>\n  <span class="token property">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",l.createElement(n.h5,{id:"payload",style:{position:"relative"}},l.createElement(n.a,{href:"#payload","aria-label":"payload permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Payload"),"\n",l.createElement(n.p,null,"Token 的第二部分是荷载（Payload)，荷载中包含声明（claims)。"),"\n",l.createElement(n.p,null,"声明其实就是要在 Token 中存储的信息，比如你的 User 对象，也可以有其他一些额外的信息（这个就是 JWT 特点体现，可以自身携带信息，不再需要服务端存储）。"),"\n",l.createElement(n.p,null,"声明有三种类型（关于这个类型不必过多关注，对使用没有太大影响，了解即可）："),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"预设（registered）：预设就是提前定义好的声明，JWT 不强制要求添加这些声明，但是建议添加，因为可以提供一组可操作性比较强的有用信息。"),"\n"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text"># 大家注意这里的声明键名都是三个字母的，因为用于网络通讯， 所以 JWT 要求紧凑\niss (issuer)\nexp (expiration time)\nsub (subject)\naud (audience)</code></pre></div>'}}),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"公开（public）：这个就随用户自己随便定义了，当然为了避免命名冲突，一般建议使用",l.createElement(n.a,{href:"https://www.iana.org/assignments/jwt/jwt.xhtml"},"IANA JSON Web Token Registry"),"里面的名字，或者用 URI 做为命名空间, 比如",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">xxxx.com_username</code>'}})),"\n",l.createElement(n.li,null,"以及私有（private）：这个其实主要是用来传输数据用的。"),"\n"),"\n",l.createElement(n.p,null,"一段有效的荷载如下："),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>\n  <span class="token property">"sub"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>\n  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>\n  <span class="token property">"admin"</span><span class="token operator">:</span> <span class="token boolean">true</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,l.createElement(n.em,null,l.createElement("font",{color:"red"},"需要大家注意的是：虽然 JWT 可以有效的防止数据被篡改，但是 Token 对于任何人来说其实还是可读的（其实相当于明文传输），所以不要将敏感信息放在 JWT 中")))),"\n",l.createElement(n.h5,{id:"signature",style:{position:"relative"}},l.createElement(n.a,{href:"#signature","aria-label":"signature permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Signature"),"\n",l.createElement(n.p,null,"Token 中最后一部分就是签名，签名使得服务端可以对 Token 做有效性校验（是否服务端颁发以及是否有被篡改）。"),"\n",l.createElement(n.p,null,"签名的算法就使用 Token Meta 中声明的算法，假设我们要使用 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">HMAC SHA256</code>'}})," 进行签名，那么操作如下："),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="javascript"><pre class="language-javascript"><code class="language-javascript"><span class="token constant">HMACSHA256</span><span class="token punctuation">(</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span> secret<span class="token punctuation">)</span></code></pre></div>'}}),"\n",l.createElement(n.p,null,"在获取到签名字符串之后，我们将其和之前的两部分放在一起，组成最终的 JWT。"),"\n",l.createElement(n.img,{src:"https://raw.githubusercontent.com/w1zd/image-hosting/main/img/2022/05/10/11-56-08-7eff2d69391c0683d058e0f5dc9049bb-encoded-jwt3-5de3fb.png",alt:"encoded-jwt3.png"}),"\n",l.createElement(n.h3,{id:"jwt-请求流程",style:{position:"relative"}},l.createElement(n.a,{href:"#jwt-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B","aria-label":"jwt 请求流程 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"JWT 请求流程"),"\n",l.createElement(n.img,{src:"https://raw.githubusercontent.com/w1zd/image-hosting/main/img/2022/05/10/11-55-41-6f08165be2cc0e587243f29b5202a0fb-jwt-sequence-8a9509.png",alt:"jwt-sequence"}),"\n",l.createElement(n.h3,{id:"jwt-优势",style:{position:"relative"}},l.createElement(n.a,{href:"#jwt-%E4%BC%98%E5%8A%BF","aria-label":"jwt 优势 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"JWT 优势"),"\n",l.createElement(n.p,null,"JWT 在现代应用开发中很受欢迎，原因有如下几点："),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"开销小，占用资源少（因为 JWT 自身携带信息，不需要在服务端进行存储，这样减少存储开支的同时也能省略查库操作提升效率）"),"\n",l.createElement(n.li,null,"能够很方便的进行跨域使用（比如第三方授权，或者集群中 SSO）"),"\n",l.createElement(n.li,null,"可以使用 JWT 实现安全的数据传输（这个特性很少用，目前关注点更多的放在令牌的签名校验上）"),"\n"),"\n",l.createElement(n.h3,{id:"使用-jwt-要注意的问题",style:{position:"relative"}},l.createElement(n.a,{href:"#%E4%BD%BF%E7%94%A8-jwt-%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98","aria-label":"使用 jwt 要注意的问题 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"使用 JWT 要注意的问题"),"\n",l.createElement(n.h4,{id:"token-注销的问题",style:{position:"relative"}},l.createElement(n.a,{href:"#token-%E6%B3%A8%E9%94%80%E7%9A%84%E9%97%AE%E9%A2%98","aria-label":"token 注销的问题 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Token 注销的问题"),"\n",l.createElement(n.p,null,"服务端不会存储 Token 相关信息，所以 Token 是否有效是由其自身决定的，这样的话服务端是无法主动让 Token 失效的。"),"\n",l.createElement(n.p,null,"那么问题来了，用户如何注销 Token？"),"\n",l.createElement(n.p,null,"最简单直接的办法就是删掉客户端存储的 Token 即可，客户端没了 Token，那么自然就没了访问权限。等等，这不就意味着我们只是删掉了那个 Token, 但是实际上 Token 还是有效的不是么？"),"\n",l.createElement(n.p,null,"怎么确保这个 Token 的确是失效的呢？"),"\n",l.createElement(n.p,null,"目前常见的方案是“黑名单策略”，即在服务器端维护一张表来存储还在有效期内但又需要让其失效的 Token，表内存储用户 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">UUID</code>'}})," 以及注销操作的时间 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">SignOutTime</code>'}}),"，在下次请求来的时候，使用用户 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">UUID</code>'}})," 在黑名单表内进行查询，如果找到了相应记录，且当前 Token 的签发时间在 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">SignOutTime</code>'}})," 之前，则判定当前 Token 无效。"),"\n",l.createElement(n.h4,{id:"token-自动续签问题",style:{position:"relative"}},l.createElement(n.a,{href:"#token-%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE%E9%97%AE%E9%A2%98","aria-label":"token 自动续签问题 permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Token 自动续签问题"),"\n",l.createElement(n.p,null,"我们都知道 Session 采用的是滑动时间制，即当用户在指定时间内再次请求服务器，则 Session 有效时长从当前时间自动顺延规定时长，这样就能达到续签的效果。"),"\n",l.createElement(n.p,null,"那么不存在这种机制的 JWT 如何做续签？"),"\n",l.createElement(n.p,null,"在实际应用场景中，比如微信公众号，他的 Token 有效时长为 3600s, 到期之后不会自动续签，客户端需要自行重新请求服务器签发新 Token。"),"\n",l.createElement(n.p,null,"JWT 中会存储用户信息，所以处于安全考虑，有效期一般都会设置比较短，但是针对 C 端的应用来讲，如上微信公众号的方式就变得不太友好，用户用一会儿就得重新输入用户名密码获取新的 Token。所以出于用户体验考虑，Token 自动续签显得尤为重要。"),"\n",l.createElement(n.p,null,"现在常用的做法为如下："),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"登录后，向客户端发送2个令牌（",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}}),"，",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">refresh_token</code>'}}),"）。"),"\n",l.createElement(n.li,null,l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}})," 有效期设置较短，而 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">refresh_token</code>'}})," 有效期设置较长。"),"\n",l.createElement(n.li,null,"客户端（前端）将 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}})," 存储在 LocalStorage 中，将 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}})," 存储在 cookie 中。"),"\n",l.createElement(n.li,null,"客户端将使用 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}})," 来调用正常API。 但是，当 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}})," 过期时，需要从本地存储中获取 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">refresh_token</code>'}}),"，然后调用身份验证服务器的 API 来获取新的 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}})," 。"),"\n",l.createElement(n.li,null,"身份验证服务器需要公开一个 API，该 API 接受 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">refresh_token</code>'}}),"并检查其有效性并返回新的 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}})," 。"),"\n",l.createElement(n.li,null,"刷新令牌过期后，注销用户不再返回新的 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">access_token</code>'}}),"。"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,l.createElement(n.em,null,"注意这里的 ",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">refresh_token</code>'}})," 只是另一个包含更少声明（Claims）的 JWT"))),"\n",l.createElement(n.p,null,"未经允许不得转载~ thx！"))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,t.RP)(),e.components);return n?l.createElement(n,e,l.createElement(s,e)):s(e)},r=a(1468),o=a(7947),i=a(1327),p=a(2171),m=a(9739);const h=e=>{let{data:n,pageContext:a,children:s}=e;const c=n.mdx,{title:h,postCopyright:d,author:u,siteUrl:g}=n.site.siteMetadata,{previous:E,next:k}=a,v=(0,r.d4)((e=>e.isDarkMode));return(0,l.useEffect)((()=>{(0,m.A)(".post-content img",{background:"#292a2d"})}),[]),l.createElement(o.A,{isFocus:!1,title:c.frontmatter.title,description:c.frontmatter.description},l.createElement("div",{className:"container"},l.createElement("article",{className:"post-wrap"},l.createElement("header",{className:"post-header"},l.createElement("h1",{className:"post-title"},c.frontmatter.title),l.createElement("div",{className:"post-meta"},n.site.siteMetadata.author.name,"  /  ",l.createElement("span",{className:"post-time"},c.frontmatter.date)," ")),l.createElement("div",{className:"post-content"},l.createElement(t.xA,null,s)),d&&l.createElement("section",{className:"post-copyright"},l.createElement("p",{className:"copyright-item"},l.createElement("span",null,"Author: "),l.createElement("span",null,u.name)),l.createElement("p",{className:"copyright-item"},l.createElement("span",null,"Permalink:"),l.createElement("span",null,l.createElement("a",{href:g+c.fields.slug}," ",g+c.fields.slug," "))),l.createElement("p",{className:"copyright-item"},l.createElement("span",null,"License: "),l.createElement("span",null,l.createElement("a",{href:"http://creativecommons.org/licenses/by-nc/4.0/"},"CC-BY-NC-4.0")))),l.createElement("section",{className:"post-tags"},l.createElement("div",null,l.createElement("span",null,"Tag(s):"),l.createElement("span",{className:"tag"},0!==c.frontmatter.tags.length&&c.frontmatter.tags.map((e=>l.createElement("a",{key:e,href:`/tag/${e}`},"#",e))))),l.createElement("div",null,l.createElement("a",{href:"#/",onClick:()=>{window.history.back()}},"back"),l.createElement("span",null," · "),l.createElement("a",{href:n.site.siteMetadata.siteUrl},"home"))),l.createElement("section",{className:"post-nav"},E?l.createElement("a",{className:"prev",rel:"prev",href:E.fields.slug},E.frontmatter.title):l.createElement("span",{className:"prev"},"No More"),k?l.createElement("a",{className:"next",rel:"next",href:k.fields.slug},k.frontmatter.title):l.createElement("span",{className:"next"},"No More")),l.createElement(p.A,{id:"comment",repo:"w1zd/w1zd.github.io",repoId:"MDEwOlJlcG9zaXRvcnkyODg3MTA5NjA=",category:"Announcements",categoryId:"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE1OTcy",mapping:"og:title",theme:`https://wizd.dev/giscus-themes/${v?"dark":"light"}.css`,reactionsEnabled:"1",loading:"lazy"}),c.frontmatter.toc&&l.createElement(i.A,null))))};function d(e){return l.createElement(h,e,l.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-tsx-content-file-path-content-blog-http会话机制及jwt原理浅析-md-332f00b83181f0ac7990.js.map